[vipr-source-repo]: https://github.com/microsoft/vipr

[![Состояние сборки](https://o365exchange.visualstudio.com/O365%20Sandbox/_apis/build/status/Microsoft%20Graph/msgraph-package-typewriter)](https://o365exchange.visualstudio.com/O365%20Sandbox/_build/latest?definitionId=1728)

# Средство создания кода SDK Microsoft Graph

Средства записи исходного кода для [VIPR][vipr-source-repo] с использованием шаблонов Т4. GraphODataTemplateWriter получает OdcmModel из VIPR и использует его для заполнения шаблона Т4, расположенного в этом репозитории.

В настоящее время в этом средстве записи поддерживаются следующие целевые языки:
- Android
- CSharp
- Java
- Objective-C
- Python
- TypeScript
- PHP

# Содержимое
- [Предварительные требования](#prerequisites)
- [Начало работы](#getting-started)
- [Использование Vipr с этим средством записи](#using-vipr-with-this-writer)
- [Участие](#contributing)
- [Лицензия](#license)

## Предварительные требования
- [Пакет SDK для Visual Studio](https://msdn.microsoft.com/ru-ru/library/bb166441.aspx)
- [Пакет SDK моделирования для Visual Studio](https://msdn.microsoft.com/ru-ru/library/bb126259.aspx)

# Начало работы

В этом проекте используются подмодули git для интеграции восходящих зависимостей, в частности [Vipr][vipr-source-repo]. Если вам требуется другое ответвление, чтобы включить специальные исправления, понадобится извлечь его вручную в подмодуле.

Чтобы решение открывалось правильно, перед его открытием в Visual Studio убедитесь, что подмодули обновлены. При исходном копировании этого репозитория используйте команду `git clone --recursive` для одновременного обновления подмодулей. Позже выполните команду `git submodule update`, чтобы обновить подмодули вручную. Если вы не используете параметр `--recursive` при клонировании, сначала выполните команду `git submodule init`, чтобы инициализировать подмодуль.

Завершив настройку, вы сможете работать в решении GraphODataTemplateWriter обычным образом. Если у вас возникли проблемы, обновите пакеты NuGet и ссылки проекта.

Чтобы получить сведения о подмодулях, обратитесь к [этой главе](http://git-scm.com/book/en/v2/Git-Tools-Submodules) из книги по Git и поиску в Интернете.

## Использование Typewriter

Typewriter — это новое решение для создания файлов кода с использованием GraphODataTemplateWriter и VIPR. Это исполняемое решение, предназначенное для упрощения создания файлов кода. Создайте решение, чтобы найти исполняемый файл typewriter в `\MSGraph-SDK-Code-Generator\src\Typewriter\bin\Release`. Параметры запуска typewriter:

* **-l**, **-language**. Целевой язык для создаваемых файлов кода. Возможные значения: `Android`, `Java`, `ObjC`, `CSharp`, `PHP`, `Python`, `TypeScript` или `GraphEndpointList`. По умолчанию установлено значение `CSharp`. Это неприменимо только при создании пустых и аннотированных метаданных, указываемых с помощью параметра `-generationmode Metadata`.
* **-m**, **-metadata**. Локальный путь к файлу или URL-адрес целевых входных метаданных. Значение по умолчанию — `https://graph.microsoft.com/v1.0/$metadata`. Это обязательное значение.
* **-v**, **-verbosity**. Уровень детализации журнала. Возможные значения: `Minimal`, `Info`, `Debug` или `Trace`. По умолчанию установлено значение `Minimal`.
* **-o**, **-output**. Указывает путь к выходной папке. Значением по умолчанию является каталог, содержащий файл typewriter.exe. Структура и содержимое выходного каталога зависит от параметров `-generationmode` и `-language`.
* **-d**, **-docs**. Указывает путь к локальной корневой папке репозитория [microsoft-graph-docs](https://github.com/microsoftgraph/microsoft-graph-docs). Значением по умолчанию является каталог, содержащий файл typewriter.exe. Выполняется разбор документации для предоставления аннотаций к метаданным, которые затем применяются для добавления комментариев документов в созданных файлах кода. Этот параметр требуется при использовании значений `Metadata` или `Full` для `-generationmode`.
* **-g**, **-generationmode**. Указывает режим создания. Возможные значения: `Full`, `Metadata` или `Files`. В режиме создания `Full` (по умолчанию) создаются выходные файлы кода путем очистки исходных метаданных, разбора документации и добавления аннотаций перед созданием выходных файлов. В режиме создания `Metadata` создаются выходные файлы метаданных путем очистки метаданных, разбора документов и добавления аннотаций к документам. В режиме создания `Files` создаются файлы кода из исходных метаданных и пропускается очистка, разбор документации и добавление аннотаций к документам.
* **-f**, **-outputMetadataFileName**. Имя файла с основными выходными метаданными. Применимо только для режима `-generationmode Metadata`. Значение по умолчанию — `cleanMetadataWithDescriptions`, используемое со значением `-endpointVersion` для создания файла метаданных `cleanMetadataWithDescriptionsv1.0.xml`.
* **-e**, **-endpointVersion**. Версия конечной точки, используемая при именовании файла метаданных. Предполагаемые значения: `v1.0` и `beta`. Применимо только для режима `-generationmode Metadata`.
* **-p**, **-properties**. Определите свойства, поддерживающие логику создания в шаблонах T4. Свойства должны быть представлены в формате *строка-ключа:строка-значения*. Можно настроить несколько свойств, указывая пробел между ними. В настоящее время поддерживается единственное свойство *php.namespace* для указания пространства имен файлов создаваемой модели. Это необязательное свойство.

### Пример использования typewriter

#### Создание вводимых элементов TypeScript из файла CSDL (метаданные) без очистки или добавления аннотаций к CSDL.

Выходные данные будут добавлены в каталог `outputTypeScript`.

`.\typewriter.exe -v Info -m D:\cleanMetadataWithDescriptions_v10.xml -o outputTypeScript -l TypeScript -g Files`

#### Очистка и добавление аннотаций в файл метаданных с использованием аннотаций к документации, полученных из репозитория документации

Выходной файл метаданных добавляется в каталог `output2`. Выходной файл метаданных будет называться `cleanMetadataWithDescriptionsv1.0.xml` на основе значений, используемых по умолчанию.

`.\typewriter.exe -v Info -m D:\v1.0_2018_10_23_source.xml -o output2 -d D:\repos\microsoft-graph-docs -g Metadata`

#### Создание файлов кода C# из метаданных, которые будут очищены с добавлением аннотаций документов из репозитория документации

Выходные файлы кода C# будут добавлены в каталог `output`.

`.\typewriter.exe -v Info -m D:\v1.0_2018_10_23_source.xml -o output -l CSharp -d D:\repos\microsoft-graph-docs -g Full`



## Использование Vipr с этим средством записи

1. Создайте решение в Visual Studio.
2. Перейдите в папку `src\GraphODataTemplateWriter\bin\debug`, чтобы найти все скомпилированные компоненты.
3. В этой папке измените файл `.config\TemplateWriterSettings.json`, чтобы указать сопоставление шаблона. Дополнительные сведения см. в разделе [Параметры средства записи шаблонов](##Template-Writer-Settings).
4. Откройте командную строку в качестве администратора из той же папки и выполните команду `Vipr.exe <path-or-url-to-metadata> --writer="GraphODataTemplateWriter"`. Пример файла метаданных можно найти в корне этого проекта.

По умолчанию выходной исходный код помещается в папку с именем output рядом с исполняемым файлом Vipr.

## Параметры средства записи шаблонов
### Доступные языки

В настоящее время можно выбирать из пяти языков: Java, ObjC, CSharp, TypeScript и Python. Укажите нужный язык для создания в параметре `TargetLanguage`.

### Шаблоны
Вы должны указать каталог шаблона в параметрах `TemplatesDirectory`. Это может быть полный путь или путь относительно текущего каталога. Каталог должен содержать вложенный каталог для каждой платформы, для которой нужно создать код. Пример см. в каталоге шаблонов.

### Сопоставление шаблонов
Требуется сопоставить шаблоны T4 с определенными субобработчиками для каждой платформы, которую нужно создать. Параметр `TemplateMapping` — это словарь языков и список шаблонов. В каждом шаблоне должно быть указаны следующие параметры:

- `Template`. Имя шаблона без расширений.
- `SubProcessor`. Субобработчик для шаблона. См. раздел [Субобработчики](#SubProcessors).
- `Type`. Тип шаблона.
- `Name`. Строка формата для имени.

и при необходимости:

- `Include`. Разделенный точками с запятой список объектов для включения в субобработчик.
- `Exclude`. Разделенный точками с запятой список объектов для исключения из субобработчика.
- `Ignore`. Разделенный точками с запятой список объектов для игнорирования субобработчиком.
- `Matches`. Разделенный точками с запятой список объектов для включения в субобработчик.
- `FileCasing`, `UpperCamel`, `LowerCamel` или `Snake` для стиля регистра определенного создаваемого файла.

**Примечание. Многие из этих необязательных параметров использовались до полной поддержки аннотаций в Vipr. Теперь, после добавления аннотаций в Vipr, использование этих параметров должно ограничиваться устаревшими сценариями.**

Пример:

` { "Template": "EntityCollectionPage", "SubProcessor": "NavigationCollectionProperty", "Type": "Request", "Name": "<Class><Property>CollectionPage", "Matches" : "includeThisType", "Exclude" : "ExcludedTypeName;OtherExcludedTypeName" }`

Важно понимать, что субобработчики сопоставлены с методами, запрашивающими объект **OdcmModel** и возвращающими набор объектов OData. Это сопоставление обеспечивается в методе [TemplateProcess.InitializeSubprocessor()](https://github.com/microsoftgraph/MSGraph-SDK-Code-Generator/blob/dev/src/GraphODataTemplateWriter/TemplateProcessor/TemplateProcessor.cs#L54). В [каталоге конфигурации](https://github.com/microsoftgraph/MSGraph-SDK-Code-Generator/tree/dev/src/GraphODataTemplateWriter/.config) существуют сопоставления для конкретных языков. Каждый объект OData, возвращаемый субобработчиком, применяется к сопоставленному шаблону, что приводит к созданию выходного файла кода для каждого объекта OData.

В примере выше каждый объект итогового набора субобработчика NavigationCollectionProperty будет применяться к шаблону EntityCollectionPage. Каждый результат будет файлом кода для каждого объекта, возвращаемого субобработчиком NavigationCollectionProperty. 

#### Субобработчики

Субобработчики определяют, какой тип объекта OData будет передан в шаблон, создающий файл кода.

- `CollectionMethod`. Все методы, являющиеся типом коллекций
- `CollectionProperty`. Свойства, являющиеся типом коллекции
- `CollectionReferenceProperty`. Все свойства навигации, являющиеся типом коллекции, применяемым в неавтономных коллекциях
- `ComplexType`. Все сложные типы
- `EntityContainer`. Контейнер объекта
- `EntityReferenceType`. Все типы объектов, используемые в неавтономных коллекциях
- `EntityType`. Все типы объектов
- `EnumType`. Все перечисляемые типы
- `MediaEntityType`. Все типы объектов мультимедиа
- `Method`. Все действия и функции
- `MethodWithBody`. Все методы и функции, отправляющие текст в HTTP-запросе
- `NavigationCollectionProperty`. Все свойства навигации, являющиеся типом коллекции
- `NonCollectionMethod`. Все методы и функции, не возвращающие коллекцию
- `Other`. Вся модель.
- `Property`. Все типы свойств
- `StreamProperty`. Все типы свойств, возвращающие потоки

#### Типы

Тип шаблона.

- `Request`. Шаблон, выполняющий запрос
- `Model`. Модель
- `Shared`. Шаблон, не создающий выходного кода, но включаемый другими шаблонами
- `Client`. Шаблон, используемый для создания объекта Client
- `Other`. Любой другой тип


#### Имя шаблона

Чтобы задать имя шаблона, используется строка формата `Name`. Вы можете вставить элементы `<Class>`, `<Property>`, `<Method>` и `<Container>`, значения которых будут заменены именами соответствующих объектов. Если вставить отсутствующий элемент, он будет заменен пустой строкой. Примечание. Также можно настроить имя шаблона изнутри шаблона с помощью
параметра: `host.SetTemplateName("foo");`

#### Редактирование шаблона

Решение содержит несобираемый проект для размещения фактических шаблонов T4 и упрощения их просмотра и изменения. Этот проект автоматически обнаруживает новые файлы шаблонов.

#### Включение и исключение

В определенные моменты вам может понадобиться исключить или обработать только некоторые объекты в субобработчике. Для этого вы можете настроить разделенный точками с запятой список объектов, которые нужно включать: `Include : foo;bar`. При этом обрабатываются только объекты с именами foo или bar. Противоположностью является параметр исключения, при использовании которого субобработчик включает все объекты, кроме содержащихся в списке исключения. Параметры исключения и включения нельзя применять совместно.

#### Игнорирование и совпадения
Если нельзя использовать имя объекта для включения или исключения, можно применить элемент длинного описания для любого объекта. Вставьте длинное описание с разделенным точками с запятой списком строк, например: `foo;bar;baz`. Если добавить `"Matches" : "foo;baz"`, будут обрабатываться только объекты, содержащие foo и baz в своем длинном описании. Противоположные действия применяются при использовании параметра Ignore.

Примечание. Вы также можете вернуть шаблон с помощью параметра `odcjObject.LongDescriptionContains("foo");`

**Примечание. Параметры включения/исключения и игноирования/соответствия использовались до полной поддержки аннотаций в Vipr. Теперь, после добавления аннотаций в Vipr, использование этих параметров должно ограничиваться устаревшими сценариями.**

## Сборка с использованием метаданных Graph

В настоящее время необходимо выполнить несколько действий, чтобы сформировать метаданные в виде объекта, который успешно создает нужные пакеты SDK:

  - Удалите аннотации к возможностям (см. [\#132](https://github.com/Microsoft/Vipr/issues/132))
  - Добавьте навигационную аннотацию к эскизу
     ```xml
     <Annotation String="navigable" Term="Org.OData.Core.V1.LongDescription"/>
     ```
  - Удалите свойства HasStream из объектов ```onenotePage``` и ```onenoteEntityBaseModel```
  - Добавьте параметр ```ContainsTarget="true"``` в свойства навигации, не содержащие соответствующего объекта EntitySet. В настоящее время это относится к свойствам навигации, содержащим объекты plannerBucket, plannerTask, plannerPlan и plannerDelta.
  - Добавьте длинные описания для типов и свойств из [документации](https://developer.microsoft.com/ru-ru/graph/docs/concepts/overview)

Чтобы выполнить сборку с использованием метаданных, отличных от сохраненных в каталоге [metadata](https://github.com/microsoftgraph/MSGraph-SDK-Code-Generator/tree/master/metadata), вам потребуется выполнить первые четыре действия этого списка.

## Участие

Перед принятием запроса на включение внесенных изменений вам потребуется в электронном виде принять [лицензионное соглашение участника](https://cla.microsoft.com/) от корпорации Майкрософт. Если вы сделали это для других проектов Майкрософт, повторное действие не требуется.

Этот проект соответствует [правилам поведения разработчиков открытого кода Майкрософт](https://opensource.microsoft.com/codeofconduct/). Дополнительные сведения см. в разделе [часто задаваемых вопросов о правилах поведения](https://opensource.microsoft.com/codeofconduct/faq/). Если у вас возникли вопросы или замечания, напишите нам по адресу [opencode@microsoft.com](mailto:opencode@microsoft.com).

[Почему CLA?](https://www.gnu.org/licenses/why-assign.html) (из FSF)

## Лицензия

© Корпорация Майкрософт. Все права защищены. Предоставляется по [лицензии MIT](LICENSE).
